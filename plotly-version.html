<!DOCTYPE html>
<html lang="en-US">
  <head>
    <!-- Meta Tags -->
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="theme-color" content="#eccc68" />
    <meta name="msapplication-navbutton-color" content="#eccc68" />
    <meta name="apple-mobile-web-app-status-bar-style" content="#eccc68" />
    <meta
      name="description"
      content="My Duolingo History - Interactive Version"
    />

    <!-- CDN -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-gH2yIJqKdNHPEq0n4Mqa/HGKIhSkIHeL5AyhkYV8i59U5AR6csBvApHHNl/vI1Bx"
      crossorigin="anonymous"
    />

    <!-- Plotly.js -->
    <script src="https://cdn.plot.ly/plotly-2.26.0.min.js"></script>

    <!-- Favicon -->
    <link rel="icon" type="image/png" href="favicon.png" />

    <!-- Title -->
    <title>My Duolingo Visualizer - Interactive</title>
  </head>

  <body>
    <main class="col-md-12 mx-auto p-3 p-md-4">
      <header>
        <h1 class="display-5 fs-1 fw-bold text-center">
          My Duolingo Visualizer - Interactive
        </h1>
      </header>

      <section class="my-4">
        <div class="d-flex justify-content">
          <span class="fw-bold lead pe-2">#</span>
          <p class="fw-bold lead shadow-lg">
            <mark>About</mark>
          </p>
        </div>

        <div>
          <p>
            Interactive visualization of my Duolingo progress with dynamic aggregation.
            Built with <kbd>Plotly.js</kbd> for advanced interactivity.
          </p>
        </div>
      </section>

      <!-- Summary Statistics Section -->
      <section class="my-4">
        <div class="d-flex justify-content">
          <span class="fw-bold lead pe-2">#</span>
          <p class="fw-bold lead shadow-lg">
            <mark>Summary Statistics</mark>
          </p>
        </div>

        <div class="row g-3 mb-2">
          <div class="col-md-4 col-sm-6">
            <div class="card border-primary">
              <div class="card-body text-center">
                <h3 class="card-title text-primary mb-1" id="totalXp">-</h3>
                <p class="card-text text-muted">Total XP</p>
              </div>
            </div>
          </div>
          <div class="col-md-4 col-sm-6">
            <div class="card border-warning">
              <div class="card-body text-center">
                <h3 class="card-title text-warning mb-1" id="currentStreak">-</h3>
                <p class="card-text text-muted">Current Streak</p>
              </div>
            </div>
          </div>
          <div class="col-md-4 col-sm-6">
            <div class="card border-success">
              <div class="card-body text-center">
                <h3 class="card-title text-success mb-1" id="totalCrowns">-</h3>
                <p class="card-text text-muted">Total Crowns</p>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Language flags positioned under Total XP -->
        <div class="row g-1 mb-4">
          <div class="col-md-4 col-sm-6">
            <div class="row g-1" id="languageCards">
              <!-- Language cards will be populated by JavaScript -->
            </div>
          </div>
          <div class="col-md-8 col-sm-6">
            <!-- Empty space to maintain alignment -->
          </div>
        </div>
      </section>

      <!-- Aggregation Controls -->
      <section class="my-4">
        <div class="d-flex justify-content-between align-items-center">
          <div>
            <span class="fw-bold lead pe-2">#</span>
            <p class="fw-bold lead shadow-lg d-inline">
              <mark>Data Aggregation</mark>
            </p>
          </div>
          <div class="btn-group" role="group" aria-label="Aggregation controls">
            <input type="radio" class="btn-check" name="aggregation" id="daily" value="daily" checked>
            <label class="btn btn-outline-primary" for="daily">Daily</label>

            <input type="radio" class="btn-check" name="aggregation" id="weekly" value="weekly">
            <label class="btn btn-outline-primary" for="weekly">Weekly</label>

            <input type="radio" class="btn-check" name="aggregation" id="monthly" value="monthly">
            <label class="btn btn-outline-primary" for="monthly">Monthly</label>
          </div>
        </div>
      </section>

      <!-- Experience Graph -->
      <section class="my-4">
        <div class="d-flex justify-content">
          <span class="fw-bold lead pe-2">#</span>
          <p class="fw-bold lead shadow-lg"><mark>Experience Graph</mark></p>
        </div>

        <div>
          <p>Interactive graph of daily XP with aggregation controls.</p>
        </div>

        <div id="experienceGraph" style="height: 500px;"></div>
      </section>

      <!-- Time Graph -->
      <section class="my-4">
        <div class="d-flex justify-content">
          <span class="fw-bold lead pe-2">#</span>
          <p class="fw-bold lead shadow-lg"><mark>Time Graph</mark></p>
        </div>

        <div>
          <p>Minutes spent per day with aggregation options.</p>
        </div>

        <div id="timeGraph" style="height: 500px;"></div>
      </section>

      <!-- Sessions Graph -->
      <section class="my-4">
        <div class="d-flex justify-content">
          <span class="fw-bold lead pe-2">#</span>
          <p class="fw-bold lead shadow-lg"><mark>Sessions Graph</mark></p>
        </div>

        <div>
          <p>Number of sessions per day with dynamic aggregation.</p>
        </div>

        <div id="sessionsGraph" style="height: 500px;"></div>
      </section>

      <!-- Streak Graph -->
      <section class="my-4">
        <div class="d-flex justify-content">
          <span class="fw-bold lead pe-2">#</span>
          <p class="fw-bold lead shadow-lg"><mark>Streak Graph</mark></p>
        </div>

        <div>
          <p>Daily streak with interactive controls.</p>
        </div>

        <div id="streakGraph" style="height: 500px;"></div>
      </section>

      <footer>
        <nav class="d-flex justify-content-center">
          <code style="font-size: 10px" class="fw-lighter text-center">
            Made with &hearts;, Plotly.js, and automation &bull;
            <a href="index.html" class="link-primary">View Chart.js version</a>
          </code>
        </nav>
      </footer>
    </main>

    <!-- Bootstrap -->
    <script
      src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.5/dist/umd/popper.min.js"
      integrity="sha384-Xe+8cL9oJa6tN/veChSP7q+mnSPaj5Bcu9mPX5F5xIGE0DVittaqT5lorf0EI7Vk"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/js/bootstrap.min.js"
      integrity="sha384-ODmDIVzN+pFdexxHEHFBQH3/9/vQ9uori45z4JjnFsRydbmQbmL5t1tQ0culUzyK"
      crossorigin="anonymous"
    ></script>

    <!-- Personal Script -->
    <script defer type="text/javascript">
      /**
       * Data aggregation functions
       */
      function aggregateData(data, aggregation) {
        const dates = Object.keys(data).sort();
        
        if (aggregation === 'daily') {
          return { 
            dates, 
            values: dates.map(date => data[date])
          };
        }
        
        const aggregated = {};
        
        dates.forEach(date => {
          // Parse date from YYYY/MM/DD format
          const [year, month, day] = date.split('/').map(Number);
          const dateObj = new Date(year, month - 1, day); // month is 0-indexed
          
          let key;
          
          if (aggregation === 'weekly') {
            // Get start of week (Monday)
            const startOfWeek = new Date(dateObj);
            const dayOfWeek = dateObj.getDay();
            const daysToMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1; // Sunday = 0, Monday = 1
            startOfWeek.setDate(dateObj.getDate() - daysToMonday);
            key = `${startOfWeek.getFullYear()}/${String(startOfWeek.getMonth() + 1).padStart(2, '0')}/${String(startOfWeek.getDate()).padStart(2, '0')}`;
          } else if (aggregation === 'monthly') {
            // Get start of month
            key = `${year}/${String(month).padStart(2, '0')}/01`;
          }
          
          if (!aggregated[key]) {
            aggregated[key] = {
              number_of_sessions: 0,
              session_time: 0,
              streak: 0,
              xp_today: 0,
              count: 0
            };
          }
          
          const entry = data[date];
          aggregated[key].number_of_sessions += entry.number_of_sessions;
          aggregated[key].session_time += entry.session_time;
          aggregated[key].xp_today += entry.xp_today;
          aggregated[key].streak = Math.max(aggregated[key].streak, entry.streak);
          aggregated[key].count += 1;
        });
        
        // Calculate appropriate aggregations
        Object.keys(aggregated).forEach(key => {
          const entry = aggregated[key];
          if (aggregation === 'weekly' || aggregation === 'monthly') {
            // For XP, session time, and sessions, we want the SUM
            // For streak, we want the MAXIMUM
            // Keep all values as sums/maximums (don't divide by count)
          }
          delete entry.count;
        });
        
        return {
          dates: Object.keys(aggregated).sort(),
          values: Object.values(aggregated)
        };
      }

      /**
       * Fetches the 'database' - a JSON file consisting of Duolingo progress.
       */
      async function getDataFromJSON() {
        const url = `${window.location.protocol}//${window.location.hostname}:${window.location.port}`;
        const response = await fetch(`${url}/data/duolingo-progress.json`);
        return response.json();
      }

      /**
       * Calculate running average based on aggregation level and data field
       */
      function calculateRunningAverage(values, aggregation, field = 'xp_today') {
        const windowSize = aggregation === 'daily' ? 7 : 
                          aggregation === 'weekly' ? 4 : 3; // monthly
        
        const runningAvg = [];
        for (let i = 0; i < values.length; i++) {
          const start = Math.max(0, i - windowSize + 1);
          const window = values.slice(start, i + 1);
          const avg = window.reduce((sum, v) => sum + v[field], 0) / window.length;
          runningAvg.push(Math.round(avg * 100) / 100); // Round to 2 decimal places
        }
        return runningAvg;
      }

      /**
       * Renders the experience graph with Plotly
       */
      function renderExperienceGraph(data, aggregation = 'daily') {
        const { dates, values } = aggregateData(data, aggregation);
        
        // Convert dates from YYYY/MM/DD to YYYY-MM-DD for Plotly
        const plotlyDates = dates.map(date => date.replace(/\//g, '-'));
        
        // Calculate running average
        const runningAvg = calculateRunningAverage(values, aggregation);
        
        // Find maximum value and its index
        const xpValues = values.map(v => v.xp_today);
        const maxXp = Math.max(...xpValues);
        const maxIndex = xpValues.indexOf(maxXp);
        
        console.log('Experience Graph Data:', {
          aggregation,
          dateCount: dates.length,
          firstDate: dates[0],
          lastDate: dates[dates.length - 1],
          firstPlotlyDate: plotlyDates[0],
          sampleValues: values.slice(0, 3),
          maxXp,
          maxDate: plotlyDates[maxIndex]
        });
        
        const traces = [
          {
            x: plotlyDates,
            y: runningAvg,
            type: 'scatter',
            mode: 'lines',
            name: `Running Average (${aggregation === 'daily' ? '7-day' : aggregation === 'weekly' ? '4-week' : '3-month'})`,
            line: {
              color: 'rgb(255, 99, 132)',
              width: 2,
              dash: 'dash'
            }
          },
          {
            x: plotlyDates,
            y: xpValues,
            type: 'scatter',
            mode: 'lines+markers',
            name: 'XP Gained',
            line: {
              color: 'rgb(46, 204, 113)',
              width: 3
            },
            marker: {
              color: 'rgb(52, 152, 219)',
              size: 6,
              symbol: 'star'
            },
            fill: 'tonexty',
            fillcolor: 'rgba(46, 204, 113, 0.3)'
          }
        ];

        const layout = {
          title: {
            text: `Experience Points (XP) - ${aggregation.charAt(0).toUpperCase() + aggregation.slice(1)} ${aggregation === 'daily' ? 'View' : 'Total'}`,
            font: { size: 18 }
          },
          xaxis: {
            title: 'Date',
            type: 'date'
          },
          yaxis: {
            title: 'XP Gained'
          },
          hovermode: 'x unified',
          showlegend: true,
          legend: {
            orientation: 'h',
            x: 0.5,
            xanchor: 'center',
            y: 1.02,
            yanchor: 'bottom'
          },
          plot_bgcolor: 'rgba(0,0,0,0)',
          paper_bgcolor: 'rgba(0,0,0,0)',
          annotations: [
            {
              x: plotlyDates[maxIndex],
              y: maxXp,
              text: `Max: ${maxXp} XP`,
              showarrow: true,
              arrowhead: 2,
              arrowsize: 1,
              arrowwidth: 2,
              arrowcolor: 'rgb(255, 0, 0)',
              ax: 20,
              ay: -30,
              bgcolor: 'rgba(255, 255, 255, 0.8)',
              bordercolor: 'rgb(255, 0, 0)',
              borderwidth: 1,
              font: {
                color: 'rgb(0, 0, 0)',
                size: 12
              }
            }
          ]
        };

        const config = {
          displayModeBar: true,
          modeBarButtonsToRemove: ['pan2d', 'lasso2d'],
          displaylogo: false
        };

        Plotly.newPlot('experienceGraph', traces, layout, config);
      }

      /**
       * Renders the time graph with Plotly
       */
      function renderTimeGraph(data, aggregation = 'daily') {
        const { dates, values } = aggregateData(data, aggregation);
        
        // Convert dates from YYYY/MM/DD to YYYY-MM-DD for Plotly
        const plotlyDates = dates.map(date => date.replace(/\//g, '-'));
        
        // Determine unit and conversion factor based on aggregation
        let unit, conversionFactor, yAxisTitle, maxLabel;
        if (aggregation === 'daily') {
          unit = 'minutes';
          conversionFactor = 1/60; // Convert seconds to minutes
          yAxisTitle = 'Minutes';
          maxLabel = 'min';
        } else {
          unit = 'hours';
          conversionFactor = 1/(60*60); // Convert seconds to hours
          yAxisTitle = 'Hours';
          maxLabel = 'hrs';
        }
        
        // Convert session time to appropriate unit and calculate running average
        const timeValues = values.map(v => Math.round(v.session_time * conversionFactor * 100) / 100);
        const runningAvg = calculateRunningAverage(values, aggregation, 'session_time').map(v => Math.round(v * conversionFactor * 100) / 100);
        
        // Find maximum value and its index
        const maxTime = Math.max(...timeValues);
        const maxIndex = timeValues.indexOf(maxTime);
        
        const traces = [
          {
            x: plotlyDates,
            y: runningAvg,
            type: 'scatter',
            mode: 'lines',
            name: `Running Average (${aggregation === 'daily' ? '7-day' : aggregation === 'weekly' ? '4-week' : '3-month'})`,
            line: {
              color: 'rgb(255, 99, 132)',
              width: 2,
              dash: 'dash'
            }
          },
          {
            x: plotlyDates,
            y: timeValues,
            type: 'scatter',
            mode: 'lines+markers',
            name: `Session Time (${unit.charAt(0).toUpperCase() + unit.slice(1)})`,
            line: {
              color: 'rgb(254, 177, 57)',
              width: 3
            },
            marker: {
              color: 'rgb(41, 52, 98)',
              size: 6
            },
            fill: 'tonexty',
            fillcolor: 'rgba(255, 248, 10, 0.3)'
          }
        ];

        const layout = {
          title: {
            text: `Time Spent - ${aggregation.charAt(0).toUpperCase() + aggregation.slice(1)} ${aggregation === 'daily' ? 'View' : 'Total'}`,
            font: { size: 18 }
          },
          xaxis: {
            title: 'Date',
            type: 'date'
          },
          yaxis: {
            title: yAxisTitle
          },
          hovermode: 'x unified',
          showlegend: true,
          legend: {
            orientation: 'h',
            x: 0.5,
            xanchor: 'center',
            y: 1.02,
            yanchor: 'bottom'
          },
          plot_bgcolor: 'rgba(0,0,0,0)',
          paper_bgcolor: 'rgba(0,0,0,0)',
          annotations: [
            {
              x: plotlyDates[maxIndex],
              y: maxTime,
              text: `Max: ${maxTime} ${maxLabel}`,
              showarrow: true,
              arrowhead: 2,
              arrowsize: 1,
              arrowwidth: 2,
              arrowcolor: 'rgb(255, 0, 0)',
              ax: 20,
              ay: -30,
              bgcolor: 'rgba(255, 255, 255, 0.8)',
              bordercolor: 'rgb(255, 0, 0)',
              borderwidth: 1,
              font: {
                color: 'rgb(0, 0, 0)',
                size: 12
              }
            }
          ]
        };

        const config = {
          displayModeBar: true,
          modeBarButtonsToRemove: ['pan2d', 'lasso2d'],
          displaylogo: false
        };

        Plotly.newPlot('timeGraph', traces, layout, config);
      }

      /**
       * Renders the sessions graph with Plotly
       */
      function renderSessionsGraph(data, aggregation = 'daily') {
        const { dates, values } = aggregateData(data, aggregation);
        
        // Convert dates from YYYY/MM/DD to YYYY-MM-DD for Plotly
        const plotlyDates = dates.map(date => date.replace(/\//g, '-'));
        
        // Calculate running average
        const sessionValues = values.map(v => v.number_of_sessions);
        const runningAvg = calculateRunningAverage(values, aggregation, 'number_of_sessions');
        
        // Find maximum value and its index
        const maxSessions = Math.max(...sessionValues);
        const maxIndex = sessionValues.indexOf(maxSessions);
        
        const traces = [
          {
            x: plotlyDates,
            y: runningAvg,
            type: 'scatter',
            mode: 'lines',
            name: `Running Average (${aggregation === 'daily' ? '7-day' : aggregation === 'weekly' ? '4-week' : '3-month'})`,
            line: {
              color: 'rgb(255, 99, 132)',
              width: 2,
              dash: 'dash'
            }
          },
          {
            x: plotlyDates,
            y: sessionValues,
            type: 'scatter',
            mode: 'lines+markers',
            name: 'Number of Sessions',
            line: {
              color: 'rgb(239, 91, 12)',
              width: 3
            },
            marker: {
              color: 'rgb(242, 223, 58)',
              size: 6
            },
            fill: 'tonexty',
            fillcolor: 'rgba(125, 157, 156, 0.3)'
          }
        ];

        const layout = {
          title: {
            text: `Sessions - ${aggregation.charAt(0).toUpperCase() + aggregation.slice(1)} ${aggregation === 'daily' ? 'View' : 'Total'}`,
            font: { size: 18 }
          },
          xaxis: {
            title: 'Date',
            type: 'date'
          },
          yaxis: {
            title: 'Number of Sessions'
          },
          hovermode: 'x unified',
          showlegend: true,
          legend: {
            orientation: 'h',
            x: 0.5,
            xanchor: 'center',
            y: 1.02,
            yanchor: 'bottom'
          },
          plot_bgcolor: 'rgba(0,0,0,0)',
          paper_bgcolor: 'rgba(0,0,0,0)',
          annotations: [
            {
              x: plotlyDates[maxIndex],
              y: maxSessions,
              text: `Max: ${maxSessions} sessions`,
              showarrow: true,
              arrowhead: 2,
              arrowsize: 1,
              arrowwidth: 2,
              arrowcolor: 'rgb(255, 0, 0)',
              ax: 20,
              ay: -30,
              bgcolor: 'rgba(255, 255, 255, 0.8)',
              bordercolor: 'rgb(255, 0, 0)',
              borderwidth: 1,
              font: {
                color: 'rgb(0, 0, 0)',
                size: 12
              }
            }
          ]
        };

        const config = {
          displayModeBar: true,
          modeBarButtonsToRemove: ['pan2d', 'lasso2d'],
          displaylogo: false
        };

        Plotly.newPlot('sessionsGraph', traces, layout, config);
      }

      /**
       * Renders the streak graph with Plotly
       */
      function renderStreakGraph(data, aggregation = 'daily') {
        const { dates, values } = aggregateData(data, aggregation);
        
        // Convert dates from YYYY/MM/DD to YYYY-MM-DD for Plotly
        const plotlyDates = dates.map(date => date.replace(/\//g, '-'));
        
        const trace = {
          x: plotlyDates,
          y: values.map(v => v.streak),
          type: 'scatter',
          mode: 'lines+markers',
          name: 'Streak',
          line: {
            color: 'rgb(0, 150, 255)',
            width: 3
          },
          marker: {
            color: 'rgb(88, 0, 255)',
            size: 6,
            symbol: 'diamond'
          },
          fill: 'tonexty',
          fillcolor: 'rgba(0, 215, 255, 0.3)'
        };

        const layout = {
          title: {
            text: `Streak - ${aggregation.charAt(0).toUpperCase() + aggregation.slice(1)} ${aggregation === 'daily' ? 'View' : 'Maximum'}`,
            font: { size: 18 }
          },
          xaxis: {
            title: 'Date',
            type: 'date'
          },
          yaxis: {
            title: 'Streak Days'
          },
          hovermode: 'x unified',
          showlegend: true,
          legend: {
            orientation: 'h',
            x: 0.5,
            xanchor: 'center',
            y: 1.02,
            yanchor: 'bottom'
          },
          plot_bgcolor: 'rgba(0,0,0,0)',
          paper_bgcolor: 'rgba(0,0,0,0)'
        };

        const config = {
          displayModeBar: true,
          modeBarButtonsToRemove: ['pan2d', 'lasso2d'],
          displaylogo: false
        };

        Plotly.newPlot('streakGraph', [trace], layout, config);
      }

      /**
       * Updates all charts with new aggregation
       */
      function updateCharts(aggregation) {
        console.log('Updating charts with aggregation:', aggregation);
        
        // Debug: Show data structure
        const { dates, values } = aggregateData(window.duolingoData, aggregation);
        console.log(`Aggregated data for ${aggregation}:`, {
          dateCount: dates.length,
          firstDate: dates[0],
          lastDate: dates[dates.length - 1],
          sampleValues: values.slice(0, 3)
        });
        
        renderExperienceGraph(window.duolingoData, aggregation);
        renderTimeGraph(window.duolingoData, aggregation);
        renderSessionsGraph(window.duolingoData, aggregation);
        renderStreakGraph(window.duolingoData, aggregation);
        renderSummaryStatistics();
      }

      /**
       * Renders summary statistics from DuoJSON API.
       */
      async function renderSummaryStatistics() {
        try {
          // Get username from GitHub Actions (injected during build) or local environment
          const username = "DimitarGen5";
          
          // Fetch summary statistics from DuoJSON API (using CORS proxy)
          const response = await fetch(`https://api.allorigins.win/raw?url=${encodeURIComponent(`https://duojson.com/${username}/profile.json`)}`);
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          
          const profileData = await response.json();
          console.log('DuoJSON profile data:', profileData);
          
          // Extract and display summary statistics
          document.getElementById('totalXp').textContent = (profileData.totalXp || 0).toLocaleString();
          document.getElementById('totalCrowns').textContent = (profileData.totalCrowns || 0).toLocaleString();
          document.getElementById('currentStreak').textContent = `${profileData.currentStreak || 0} days`;
          
          // Display language progress (sorted by XP descending)
          const languageCards = document.getElementById('languageCards');
          languageCards.innerHTML = '';
          
          if (profileData.languages && profileData.languages.length > 0) {
            // Sort languages by XP (descending)
            const sortedLanguages = profileData.languages.sort((a, b) => b.xp - a.xp);
            
            // Language to flag mapping
            const languageFlags = {
              'Dutch': 'üá≥üá±',
              'Japanese': 'üáØüáµ',
              'German': 'üá©üá™',
              'Russian': 'üá∑üá∫',
              'Spanish': 'üá™üá∏',
              'French': 'üá´üá∑',
              'Italian': 'üáÆüáπ',
              'Portuguese': 'üáµüáπ',
              'Chinese': 'üá®üá≥',
              'Korean': 'üá∞üá∑',
              'Arabic': 'üá∏üá¶',
              'Hindi': 'üáÆüá≥',
              'Turkish': 'üáπüá∑',
              'Polish': 'üáµüá±',
              'Swedish': 'üá∏üá™',
              'Norwegian': 'üá≥üá¥',
              'Danish': 'üá©üá∞',
              'Finnish': 'üá´üáÆ',
              'Greek': 'üá¨üá∑',
              'Hebrew': 'üáÆüá±',
              'Vietnamese': 'üáªüá≥',
              'Indonesian': 'üáÆüá©',
              'Ukrainian': 'üá∫üá¶',
              'Czech': 'üá®üáø',
              'Romanian': 'üá∑üá¥',
              'Hungarian': 'üá≠üá∫',
              'Bulgarian': 'üáßüá¨',
              'Croatian': 'üá≠üá∑',
              'Slovak': 'üá∏üá∞',
              'Lithuanian': 'üá±üáπ',
              'Latvian': 'üá±üáª',
              'Estonian': 'üá™üá™',
              'Irish': 'üáÆüá™',
              'Welsh': 'üè¥Û†ÅßÛ†Å¢Û†Å∑Û†Å¨Û†Å≥Û†Åø',
              'Swahili': 'üá∞üá™',
              'Hawaiian': 'üá∫üá∏',
              'Navajo': 'üá∫üá∏',
              'Yiddish': 'üáÆüá±',
              'Esperanto': 'üåç',
              'Klingon': 'üññ',
              'High Valyrian': 'üêâ',
              'Latin': 'üèõÔ∏è'
            };
            
            sortedLanguages.forEach((lang, index) => {
              const flag = languageFlags[lang.course] || 'üåç';
              const card = document.createElement('div');
              card.className = 'col-3';
              card.innerHTML = `
                <div class="card border-info">
                  <div class="card-body text-center p-1">
                    <div class="mb-1" style="font-size: 1rem;">${flag}</div>
                    <h6 class="card-title text-info mb-0" style="font-size: 0.7rem;">${lang.xp.toLocaleString()}</h6>
                  </div>
                </div>
              `;
              languageCards.appendChild(card);
            });
          }
          
          console.log('Summary statistics loaded successfully');
          return null;
        } catch (error) {
          console.error('Error loading summary statistics:', error);
          
          // Show error state
          document.getElementById('totalXp').textContent = 'Error';
          document.getElementById('totalCrowns').textContent = 'Error';
          document.getElementById('currentStreak').textContent = 'Error';
          document.getElementById('languageCards').innerHTML = '<div class="col-12"><p class="text-muted">Error loading language data</p></div>';
          
          return null;
        }
      }

      /**
       * Bootstraps the application
       */
      async function bootstrap() {
        try {
          console.log('Loading data...');
          const data = await getDataFromJSON();
          if (!data) {
            console.error('No data received');
            return;
          }

          window.duolingoData = data;
          console.log('Data loaded successfully:', Object.keys(data).length, 'entries');
          console.log('Sample data:', {
            firstDate: Object.keys(data)[0],
            lastDate: Object.keys(data)[Object.keys(data).length - 1],
            sampleEntry: data[Object.keys(data)[0]]
          });

          // Render initial charts
          updateCharts('daily');

          // Add event listeners for aggregation controls
          document.querySelectorAll('input[name="aggregation"]').forEach(radio => {
            radio.addEventListener('change', function() {
              if (this.checked) {
                updateCharts(this.value);
              }
            });
          });

          console.log('Application initialized successfully');
        } catch (error) {
          console.error('Error in bootstrap:', error);
        }
      }

      // Start the application
      bootstrap()
        .then(() => {
          console.log('Plotly.js visualization loaded successfully');
        })
        .catch((err) => {
          console.error('An error occurred:', err);
        });
    </script>
  </body>
</html>
